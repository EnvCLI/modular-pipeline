#!/usr/bin/env bash
set -euo pipefail

# common
LOCAL_PATH=${BASH_SOURCE%/*}
source "$LOCAL_PATH/pipeline-common"

# Public: Authenticate against a container registry
#
# This will sign in to a remote container registry.
#
# $1 - The registry hostname
# $2 - The registry username
# $3 - The registry password
#
# Examples
#
#   container_registry_login "hostname" "user" "pass"
#
# Returns the exit code of the last command executed or 0 otherwise.
container_registry_login() {
  declare registryHost="$1" registryUsername="$2" registryPassword="$3"

  _log_message "trying to login to container registry $registryHost ..." "INFO"

  if [[ -n "$registryUsername" ]]; then
    _run_command docker login -u "$registryUsername" -p "$registryPassword" "$registryHost"
  else
    _log_message "Failed to login to container registry! No credentials provided!" "ERROR"
    exit 1
  fi
}

# Public: Parse the from statement of the dockerfile
#
# Takes the filepath to a dockerfile as argument and will search for
# the FROM line. It will then check if it contains the BASE_IMAGE as
# default var and extract the default value.
# This will export the following 2 variables:
# - CONTAINER_BASE_IMAGE_REPOSITORY
# - CONTAINER_BASE_IMAGE_TAG
#
# $1 - The dockerfile that should be analysed (ie. Dockerfile)
#
# Examples
#
#   parse-dockerfile-from "Dockerfile"
#
# Returns the exit code of the last command executed or 0 otherwise.
parse_dockerfile_from() {
  declare dockerfile="$1"

  IFS=':' read -r -a baseImageArray <<< $(cat "$dockerfile" | grep "FROM \${BASE_IMAGE:-" | cut -c 20- | tr -d '}')
  export CONTAINER_BASE_IMAGE_REPOSITORY=${baseImageArray[0]}
  export CONTAINER_BASE_IMAGE_TAG=${baseImageArray[1]}
}

# Public: Parse the manifest of a container image
#
# Takes a container image as argument and evaluates the manifest. Will then export
# a variable for each entry as `MANIFEST_DIGEST_linux_amd64` which contains the
# digest of the image for that specific os/architecture.
#
# $1 - The container image that should be analysed (ie. docker.io/alpine:latest)
#
# Examples
#
#   parse-container-manifest "docker.io/alpine:latest"
#
# Returns the exit code of the last command executed or 0 otherwise.
parse_container_manifest() {
  declare containerImage="$1"

  local temporaryManifestFile="$TMP_DIR/manifest.json"
  local temporaryManifestResultFile=$(mktemp)
  docker manifest inspect "$containerImage" > "$temporaryManifestFile"
  envcli run jq '.manifests[] | [.platform.os,.platform.architecture,.platform.variant,.digest] | @csv' "$temporaryManifestFile" | tr -d '\\"' > "$temporaryManifestResultFile"
  readarray -t manifestArchs < $temporaryManifestResultFile

  # for each manifest entry
  for KEY in "${manifestArchs[@]}"; do
    _log_message "processing base image manifest line: [$KEY]" "DEBUG"

    IFS=', ' read -r -a row <<< "$KEY"
    local manifestOS="${row[0]}"
    local manifestArch="${row[1]}"
    local manifestVariant="${row[2]}"
    local manifestDigest="${row[3]}"

    # overwrite values to be conform the pipeline spec
    if echo "${manifestArch}_${manifestVariant}" | grep -q 'arm_v6'; then
      manifestArch=arm32v6
    elif echo "${manifestArch}_${manifestVariant}" | grep -q 'arm_v7'; then
      manifestArch=arm32v7
    elif echo "${manifestArch}_${manifestVariant}" | grep -q 'arm64_v8'; then
      manifestArch=arm64v8
    fi
    _log_message "setting property [${manifestOS}_${manifestArch}] to [${manifestDigest}]" "DEBUG"

    # store for later use when overwriting BASE_IMAGE via build arg
    export "MANIFEST_DIGEST_${manifestOS}_${manifestArch}=$manifestDigest"
  done
}

# Public: Create a manifest to point at images with different archs
#
# Takes a primary manifest
#
# $1 - The container image that should be created (the manifest)
# $2 - The archs that the manifest should contain
#
# Examples
#
#   create-container-manifest "docker.io/alpine:latest" "linux_amd64,linux_arm64v8"
#
# Returns the exit code of the last command executed or 0 otherwise.
create_container_manifest() {
  declare manifestName="$1" containerBuildArchs="$2"
  _log_message "generating manifest [${manifestName}] pointing at [${containerBuildArchs}]" "DEBUG"

  # args with all images contained in the manifest
  declare -a manifestArgs

  # build
  IFS=',' read -r -a artifactBuildArchArray <<< $(echo "$containerBuildArchs")
  for VALUE in "${artifactBuildArchArray[@]}"; do
    IFS='_' read -r -a row <<< "$VALUE"
    local buildOS="${row[0]}"
    local buildArch="${row[1]}"
    local variant="${buildOS}_${buildArch}"
    local imageName="${manifestName}_${variant}"

    _log_message "adding variant ${imageName} to manifestArgs for manifest creation" "DEBUG"
    manifestArgs=( "${manifestArgs[@]}" "$imageName" )
  done

  # create manifest
  _run_command docker manifest create --amend "${manifestName}" "${manifestArgs[@]}"
  _log_message "created manifest ${imageName} with variants [${manifestArgs[@]}]" "INFO"

  # manifest annotations
  IFS=',' read -r -a artifactBuildArchArray <<< $(echo "$containerBuildArchs")
  for VALUE in "${artifactBuildArchArray[@]}"; do
    IFS='_' read -r -a row <<< "$VALUE"
    local buildOS="${row[0]}"
    local buildArch="${row[1]}"
    local variant="${buildOS}_${buildArch}"
    local imageName="${manifestName}_${variant}"

    _log_message "setting image annotation for [${imageName}] with [${variant}]" "DEBUG"
    if echo "$variant" | grep -q 'linux_amd64'; then
      _run_command docker manifest annotate "$manifestName" "$imageName" \
        --os linux \
        --arch amd64
    elif echo "$variant" | grep -q 'linux_arm64v8'; then
      _run_command docker manifest annotate "$manifestName" "$imageName" \
        --os linux \
        --arch arm64 \
        --variant v8
    fi
  done

  # docker manifest push -p ownyourbits/example
}

# artifact generation
build_container() {
  declare imageRepo="$1" imageTag="$2" baseImageRepo="$3" baseImageTag="$4" buildOS="$5" buildArch="$6"

  # parse the manifest of the base image, to check what is supported
  _log_message "parsing manifest of the base image [$baseImageRepo:$baseImageTag]" "INFO"
  parse-container-manifest "$baseImageRepo:$baseImageTag"
  local digestVarName="MANIFEST_DIGEST_${buildOS}_${buildArch}"
  local overwriteWithTag=${!digestVarName}

  # build
  _log_message "building image [$imageRepo:$imageTag] for target platform [${buildOS}_${buildArch}]" "INFO"
  _log_message "will overwrite base image with: [$baseImageRepo@$overwriteWithTag]" "DEBUG"
  _run_command docker build \
    --no-cache \
    --build-arg "BASE_IMAGE=${baseImageRepo}@${overwriteWithTag}" \
    --build-arg "http_proxy=$HTTP_PROXY" \
    --build-arg "https_proxy=$HTTPS_PROXY" \
    --build-arg "proxy_host=$PROXY_HOST" \
    --build-arg "proxy_port=$PROXY_PORT" \
    -f $DOCKERFILE_NAME \
    -t ${imageRepo}:${imageTag}_${buildOS}_${buildArch} \
    $DOCKERFILE_PATH
  _log_message "image build success, tagged as [${imageRepo}:${imageTag}_${buildOS}_${buildArch}]" "INFO"

  # save image
  mkdir -p "${TMP_DIR}/container-image"
  local artifactName="${imageTag}_${buildOS}_${buildArch}"
  _run_command docker save "${imageRepo}:${imageTag}_${buildOS}_${buildArch}" > ${TMP_DIR}/container-image/${artifactName}.tar
  _log_message "stored image into ${TMP_DIR}/container-image/${artifactName}" "INFO"
}

# container registry login
function container_registry_push()
{
  declare imageRepo="$1" imageTag="$2"

  _log_message "pushing image [${imageRepo}:${imageTag}] to remote registry $NCI_CONTAINERREGISTRY_HOST ..." "INFO"
  docker push "${imageRepo}:${imageTag}"
}
