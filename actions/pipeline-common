#!/usr/bin/env bash

# debug mode
DEBUG=${DEBUG:-false}
if [ "$DEBUG" == "true" ]; then
  echo "-> Debugging mode enabled ..."
  set -x
fi

# global variables
MPI_RESOURCES_MIRROR=https://raw.githubusercontent.com/EnvCLI/modular-pipeline/master/resources

# func: logging
declare -A levels=([TRACE]=0 [DEBUG]=1 [INFO]=2 [WARN]=3 [ERROR]=4)
_log_message() {
  local log_message=$1
  local log_priority=$2

  # check if level exists
  [[ ${levels[$log_priority]} ]] || return 1

  # check if level is enough
  (( ${levels[$log_priority]} < ${levels[${SCRIPT_LOG_LEVEL:-INFO}]} )) && return 0

  # log the message
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] ${log_priority} : ${log_message}"
}

# func: run
_run_command() {
  _log_message "Command $*" "TRACE"
  eval "$@"
}

# func: run in container
_run_in_container() {
  eval _run_command envcli run "$@"
}

# func: prepare
_prepare() {
  # source in .ci/env
  if [ -f ".ci/env" ]; then
    _log_message "loading environment from .ci/env" "DEBUG"
    export $(grep -v '^#' .ci/env | xargs)
  fi

  # prerequisites
  # - docker
  if ! command -v docker > /dev/null; then
    _log_message "docker is required but missing!" "ERROR"
    exit 1
  fi
  # - envcli
  if ! command -v envcli > /dev/null; then
    _log_message "-> envcli not available. Please run theinstallation script!" "ERROR"
    exit 1
  fi

  # find container runtime (if docker info fails)
  if ! docker info &>/dev/null; then
    _log_message "trying to find a working container runtime as the current one doesn't work ..." "DEBUG"

    # set DOCKER_HOST
    set +u
    local CHOST=docker
    local CPORT=2375

    if [ -z "$DOCKER_HOST" ] && [ "$KUBERNETES_PORT" ]; then
      _log_message "detected kubernetes usage, using localhost" "DEBUG"
      CHOST=localhost
    fi
    if [ "$DOCKER_TLS_CERTDIR" ]; then
      _log_message "detected docker tls cert usage, using port 2376" "DEBUG"
      CPORT=2376
    fi

    export DOCKER_HOST="tcp://${CHOST}:${CPORT}"
    set -u
  else
    _log_message "container runtime is ready for use" "TRACE"
  fi

  # normalize ci variables
  if [ -z ${NCI+x} ]; then
    _log_message "normalizing ci variables" "TRACE"
    eval $(envcli run normalizeci)
  fi

  # ensure required variables are set
  export PROJECT_TYPE=${PROJECT_TYPE:-none}
  export DEPLOYMENT_TYPE=${DEPLOYMENT_TYPE:-none}

  # global properties
  export ARTIFACT_DIR=${ARTIFACT_DIR:-dist}
  export ARTIFACT_BUILD_ARCHS=${ARTIFACT_BUILD_ARCHS:-linux_amd64}
  export TMP_DIR=${TMP_DIR:-tmp}
  mkdir -p "$ARTIFACT_DIR" "$TMP_DIR"

  # container properties
  export CONTAINER_REPO="${CONTAINER_REPO:-$NCI_CONTAINERREGISTRY_REPOSITORY}"
  export CONTAINER_TAG="${CONTAINER_TAG:-$NCI_COMMIT_REF_RELEASE}"

  # proxy
  export HTTP_PROXY=${HTTP_PROXY:-}
  export HTTPS_PROXY=${HTTPS_PROXY:-}
  export PROXY_HOST=${PROXY_HOST:-}
  export PROXY_PORT=${PROXY_PORT:-}
  export JAVA_PROXY_OPTS="-Dhttp.proxyHost=$PROXY_HOST -Dhttp.proxyPort=$PROXY_PORT -Dhttps.proxyHost=$PROXY_HOST -Dhttps.proxyPort=$PROXY_PORT"
}

# Public: Checks if a hook with the specified name exists in the current project
#
# Will check the current directory for a file called `.ci/hooks/hookName.sh`.
#
# $1 - The name of the hook to be executed. (pre_build, post_build, ...)
#
# Examples
#
#   _run_hook "pre-build"
#
# Returns the exit code of the last command executed or 0 otherwise
_run_hook() {
  declare hookName="$1"

  # check if file exist and run it
  local hookFile="${NCI_PROJECT_DIR}/.ci/hooks/${hookName}.sh"
  if test -f "${hookFile}"; then
    _log_message "execute: repository hook [${hookName}]" "INFO"
    "${hookFile}"
  fi
}

